# Frank Claverie
# CS 416p
# Midi Demo - Extremely basic synthesizer


# Note: mido requires installing python-rtmidi controller
#       Which is a wrapper for the C library rtmidi
import mido
import numpy as np
import sounddevice as sd

# Change this to match you system spec
sample_rate = 96000
max_amplitude = np.iinfo(np.int16).max
note_buffer = {}


# Finds and opens MIDI controller
#   Currently opens first available
def open_port():
    port_names = mido.get_input_names()
    if not port_names:
        print("No MIDI input ports found.")
        exit()
    
    # print("List of available ports:")
    # for i, port in enumerate(port_names):
    #     print(f"{i}: {port}")
    # choice = int(input("Enter the number of your choice:\n>"))

    # if port_names[choice] not in port_names:
    #     print("I'm sorry dave, I'm afraid you can't select that port...")
    #     exit()

    port = port_names[0]
    return port


def midi_to_freq(midi_note:int):
    return 440.0 * (2.0 ** ((midi_note - 69) / 12.0))


# Defines the audio callback feature required for sounddevice.OutputStream()
def audio_callback(outdata, frames, time, status):
    global note_buffer

    if status:
        print(f"Error with stream: {status}")
        exit()
        
    # Create a baseline wave and time array for additive synthesis.
    t = np.arange(frames) / sample_rate
    mixed_wave = np.zeros(frames, dtype=np.float32)

    notes_to_remove = []
    buf_len = len(note_buffer)
    for note, data in note_buffer.items():
        # Using phase here to account imperfectly caputres cylces generated by the size of frames
        freq = data["freq"]
        phase = data["phase"]
        velocity = data["velocity"]

        wave = velocity * np.sin(2 * np.pi * freq * t + phase)
        mixed_wave += wave

        note_buffer[note]["phase"] = (phase + 2 * np.pi * freq * frames / sample_rate) % (2 * np.pi)

        if velocity <= 0:
            notes_to_remove.append(note)

    for note in notes_to_remove:
        del note_buffer[note]

    # Attenuating mixed wave before clipping. Seems to work alright.
    if buf_len > 0:
        mixed_wave *= 1/np.sqrt(buf_len)
    mixed_wave = np.clip(mixed_wave, -1.0, 1.0)
    outdata[:] = mixed_wave.reshape(-1, 1)


# With the passed in MIDI controller,
#   Listens for MIDI events and updates the buffer accordingly, also prints the message info... 
#       which is where I intended to stop for this demo...
def handle_midi(port):
    global note_buffer

    with mido.open_input(port) as inport:
        print(f"Listening to MIDI input: {port}")
        print("   * Press ctrl-c to end.")

        try:
            for msg in inport:
                if msg.type == "note_on" and msg.velocity > 0:
                    freq = midi_to_freq(msg.note)
                    velocity = msg.velocity / 127.0
                    if msg.note not in note_buffer:
                        note_buffer[msg.note] = {"freq": freq, "phase": 0.0, "velocity": velocity}
                    else:
                        note_buffer[msg.note]["velocity"] = velocity
                    print(f"Note ON: {msg.note}, Frequency: {freq:.2f} Hz, Velocity: {msg.velocity}")
                    
                elif msg.type == "note_off" or (msg.type == "note_on" and msg.velocity == 0):
                    if msg.note in note_buffer:
                        del note_buffer[msg.note]
                        print(f"Note OFF: {msg.note}")

                else:
                    print(f"MIDI Message: {msg}")

        except KeyboardInterrupt:
            print("\nExiting...")
            


def main():
    global note_buffer
    port = open_port()

    with sd.OutputStream(
        samplerate=sample_rate,
        channels=1,
        blocksize=512,
        callback=audio_callback
    ) as stream:
        stream.start()
        handle_midi(port)    

if __name__ == "__main__":
    main()